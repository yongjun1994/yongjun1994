# 데이터 교환 포맷 및 HTTPS/SSL 기초

이 문서는 개발자에게 필수적인 데이터 교환 포맷(JSON, XML, YAML)의 특징을 비교하고, 웹 통신의 보안을 책임지는 HTTPS와 SSL/TLS 인증서의 기본 개념을 설명합니다.

---

## 1. 데이터 교환 포맷 및 시리얼라이징

**시리얼라이징(Serialization)**이란 메모리에 있는 데이터 구조(객체 등)를 다른 컴퓨터나 프로그램이 읽고 쓸 수 있는 특정 포맷(문자열, 바이트 등)으로 변환하는 과정을 의미합니다. 이를 통해 네트워크 전송, 데이터베이스 저장, 파일 저장 등이 가능해집니다. 대표적인 데이터 교환 포맷으로는 JSON, XML, YAML이 있습니다.

### ### JSON (JavaScript Object Notation)

JSON은 JavaScript의 객체 표기법에서 파생된, 사람이 읽고 쓰기 쉬우며 기계가 파싱하고 생성하기 용이한 경량 데이터 교환 형식입니다. 현재 웹 환경에서 API 통신 및 데이터 교환의 **사실상 표준(de facto standard)**으로 사용됩니다.

* **특징**:
    * `key-value` 쌍으로 이루어진 단순한 구조.
    * 데이터 타입으로 `string`, `number`, `boolean`, `array`, `object` 지원.
    * 가독성이 높고 매우 가벼움.
    * 대부분의 프로그래밍 언어에서 파서(Parser)를 지원.

* **문법 예시**:
    ```json
    {
      "user": {
        "name": "Gildong Hong",
        "age": 30,
        "isStudent": false,
        "courses": [
          { "title": "History", "credits": 3 },
          { "title": "Math", "credits": 4 }
        ],
        "address": null
      }
    }
    ```

### ### XML (eXtensible Markup Language)

XML은 HTML과 유사한 마크업 언어로, 데이터의 **구조와 의미**를 함께 표현하는 데 중점을 둡니다. 태그를 사용자가 직접 정의할 수 있어 확장성이 뛰어납니다. 과거 웹 서비스와 복잡한 문서 구조 표현에 널리 사용되었습니다.

* **특징**:
    * `<tag>`와 `</tag>`로 데이터를 감싸는 계층적 구조.
    * 데이터와 메타데이터(속성)를 함께 표현 가능.
    * DTD(Document Type Definition)나 XSD(XML Schema Definition)를 통해 데이터 구조의 유효성 검증 가능.
    * 주석(``)을 지원.
    * JSON에 비해 무겁고 문법이 복잡함.

* **문법 예시**:
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <user>
      <name>Gildong Hong</name>
      <age>30</age>
      <isStudent>false</isStudent>
      <courses>
        <course title="History" credits="3"/>
        <course title="Math" credits="4"/>
      </courses>
      <address/>
    </user>
    ```

### ### YAML (YAML Ain't Markup Language)

YAML은 **가독성**에 초점을 맞춘 데이터 시리얼라이징 포맷입니다. 들여쓰기(indentation)를 사용하여 데이터의 계층 구조를 표현하며, 설정 파일(configuration file) 작성에 매우 인기가 높습니다.

* **특징**:
    * 들여쓰기와 `key: value` 형식으로 데이터를 표현.
    * 괄호나 태그 없이 간결하고 깔끔한 문법.
    * 주석(`#`)을 지원.
    * JSON의 상위 집합(superset)이므로, 유효한 JSON은 대부분 유효한 YAML임.
    * 복잡한 데이터 구조를 직관적으로 표현 가능.
    * 들여쓰기에 민감하여 문법 오류가 발생하기 쉬움.

* **문법 예시**:
    ```yaml
    user:
      name: Gildong Hong
      age: 30
      isStudent: false
      courses:
        - title: History
          credits: 3
        - title: Math
          credits: 4
      address: null # 주소 정보 없음
    ```

### ### 비교 요약

| 구분 항목     | JSON                                       | XML                                              | YAML                                           |
|---------------|--------------------------------------------|--------------------------------------------------|------------------------------------------------|
| **가독성** | 높음                                       | 보통 (태그 때문에 길어짐)                        | **매우 높음** |
| **문법** | `key-value` 쌍, 괄호 사용                  | 태그 기반, 계층적                                | 들여쓰기 기반, 간결함                          |
| **주요 용도** | **API, 웹 서비스** | 웹 서비스(SOAP), 문서 구조 표현                  | **설정 파일(k8s, Docker), 스크립트** |
| **경량성** | **매우 가벼움** | 무거움 (태그, 메타데이터)                        | 가벼움                                         |
| **주석 지원** | 미지원                                     | 지원 (``)                                | 지원 (`#`)                                     |
| **데이터 타입** | 문자, 숫자, 불리언, 배열, 객체             | 스키마(XSD)를 통해 다양하게 정의 가능            | 스칼라(문자, 숫자 등), 시퀀스(배열), 맵(객체)   |
| **파싱 속도** | 빠름                                       | 느림                                             | 상대적으로 느림                                |

---

## 2. HTTPS와 SSL/TLS 인증서 기초

### ### HTTPS (HyperText Transfer Protocol Secure)

HTTPS는 HTTP의 보안 강화 버전입니다. 클라이언트(웹 브라우저)와 서버 간의 모든 통신 내용을 **암호화**하여 제3자가 데이터를 가로채더라도 그 내용을 알 수 없게 만듭니다.

* **주요 목표**:
    1.  **데이터 암호화 (Encryption)**: 중간에서 데이터를 가로채도(Sniffing) 내용을 해독할 수 없도록 보호합니다.
    2.  **데이터 무결성 (Integrity)**: 데이터가 전송 중에 위변조되지 않았음을 보장합니다.
    3.  **서버 인증 (Authentication)**: 접속하려는 서버가 신뢰할 수 있는 진짜 서버임을 증명합니다.

### ### SSL/TLS 인증서 (SSL/TLS Certificate)

HTTPS 통신을 위해서는 서버가 자신의 신원을 증명하고, 암호화에 사용할 공개키를 클라이언트에게 제공해야 합니다. 이때 사용되는 것이 바로 **SSL/TLS 인증서**입니다.

* **SSL (Secure Sockets Layer)**과 **TLS (Transport Layer Security)**는 같은 역할을 하는 보안 프로토콜이며, TLS가 SSL의 후속 버전입니다. 현재는 대부분 TLS를 사용하지만, 관용적으로 'SSL 인증서'라고 부르는 경우가 많습니다.

* **SSL/TLS 인증서의 역할**:
    1.  **클라이언트가 접속한 서버가 신뢰할 수 있음을 보장**: 인증서는 **인증 기관(CA, Certificate Authority)**이라는 신뢰할 수 있는 제3자에 의해 발급됩니다. 브라우저는 이 CA를 신뢰함으로써 서버를 신뢰하게 됩니다.
    2.  **암호화 통신을 위한 공개키 제공**: 인증서 안에는 해당 서버의 **공개키(Public Key)**가 포함되어 있습니다. 클라이언트는 이 공개키를 사용하여 통신 데이터를 암호화합니다.

### ### HTTPS 통신 과정 (SSL/TLS Handshake 요약)

1.  **Client Hello**: 클라이언트(브라우저)가 서버에 접속하며 통신 가능한 암호화 방식 목록, 무작위 데이터 등을 전송합니다.
2.  **Server Hello**: 서버는 클라이언트가 보낸 암호화 방식 중 하나를 선택하고, 서버의 **SSL 인증서**와 무작위 데이터를 클라이언트에게 전송합니다.
3.  **Certificate Verification & Key Exchange**:
    * 클라이언트는 서버로부터 받은 인증서가 신뢰할 수 있는 CA로부터 발급되었는지, 유효 기간이 남았는지 등을 검증합니다.
    * 검증이 완료되면, 클라이언트는 서버의 공개키를 사용하여 앞으로 통신에 사용할 **대칭키(Symmetric Key)**를 암호화하여 서버로 보냅니다.
4.  **Finished**:
    * 서버는 자신의 **비밀키(Private Key)**로 클라이언트가 보낸 암호화된 대칭키를 복호화하여 얻습니다.
    * 이제 클라이언트와 서버는 동일한 **대칭키**를 공유하게 되었습니다. 이 대칭키를 사용하여 이후의 모든 통신 데이터를 암호화하고 복호화합니다. (대칭키 방식은 공개키 방식보다 훨씬 빠르기 때문입니다.)

이 과정을 통해 안전한 통신 채널이 구축되고, 주소창에 자물쇠 아이콘 🔒이 표시됩니다.
