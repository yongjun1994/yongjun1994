# 데이터 교환 포맷 및 HTTPS/SSL 기초

이 문서는 개발자에게 필수적인 데이터 교환 포맷(JSON, XML, YAML)의 특징을 비교하고, 웹 통신의 보안을 책임지는 HTTPS와 SSL/TLS 인증서의 기본 개념을 설명합니다.

---

## 1. 데이터 교환 포맷 및 시리얼라이징

**시리얼라이징(Serialization)**이란 메모리에 있는 데이터 구조(객체 등)를 다른 컴퓨터나 프로그램이 읽고 쓸 수 있는 특정 포맷(문자열, 바이트 등)으로 변환하는 과정을 의미합니다. 이를 통해 네트워크 전송, 데이터베이스 저장, 파일 저장 등이 가능해집니다. 대표적인 데이터 교환 포맷으로는 JSON, XML, YAML이 있습니다.

### JSON (JavaScript Object Notation)

JSON은 JavaScript의 객체 표기법에서 파생된, 사람이 읽고 쓰기 쉬우며 기계가 파싱하고 생성하기 용이한 경량 데이터 교환 형식입니다. 현재 웹 환경에서 API 통신 및 데이터 교환의 **사실상 표준(de facto standard)**으로 사용됩니다.

* **특징**:
    * `key-value` 쌍으로 이루어진 단순한 구조.
    * 데이터 타입으로 `string`, `number`, `boolean`, `array`, `object` 지원.
    * 가독성이 높고 매우 가벼움.
    * 대부분의 프로그래밍 언어에서 파서(Parser)를 지원.

* **문법 예시**:
    ```json
    {
      "user": {
        "name": "Gildong Hong",
        "age": 30,
        "isStudent": false,
        "courses": [
          { "title": "History", "credits": 3 },
          { "title": "Math", "credits": 4 }
        ],
        "address": null
      }
    }
    ```

### XML (eXtensible Markup Language)

XML은 HTML과 유사한 마크업 언어로, 데이터의 **구조와 의미**를 함께 표현하는 데 중점을 둡니다. 태그를 사용자가 직접 정의할 수 있어 확장성이 뛰어납니다.

* **특징**:
    * `<tag>`와 `</tag>`로 데이터를 감싸는 계층적 구조.
    * 데이터와 메타데이터(속성)를 함께 표현 가능.
    * DTD, XSD를 통해 데이터 구조 유효성 검증 가능.
    * 주석(`<!-- -->`) 지원.
    * JSON에 비해 무겁고 문법이 복잡함.

* **문법 예시**:
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <user>
      <name>Gildong Hong</name>
      <age>30</age>
      <isStudent>false</isStudent>
      <courses>
        <course title="History" credits="3"/>
        <course title="Math" credits="4"/>
      </courses>
      <address/>
    </user>
    ```

### YAML (YAML Ain't Markup Language)

YAML은 **가독성**에 초점을 맞춘 데이터 시리얼라이징 포맷입니다. 들여쓰기를 사용하여 계층 구조를 표현하며 설정 파일 작성에 적합합니다.

* **특징**:
    * `key: value`와 들여쓰기 기반 구조.
    * 간결하고 사람이 읽기 쉬움.
    * 주석(`#`) 지원.
    * JSON의 상위 집합.
    * 들여쓰기에 민감하여 오류가 발생하기 쉬움.

* **문법 예시**:
    ```yaml
    user:
      name: Gildong Hong
      age: 30
      isStudent: false
      courses:
        - title: History
          credits: 3
        - title: Math
          credits: 4
      address: null # 주소 없음
    ```

### 비교 요약

| 항목        | JSON                  | XML                      | YAML                     |
|-------------|-----------------------|---------------------------|--------------------------|
| 가독성      | 높음                  | 낮음                      | **매우 높음**           |
| 문법 구조   | key-value, 괄호       | 태그 기반, 중첩 구조     | 들여쓰기 기반           |
| 주 용도     | **웹 API, REST**      | 문서 데이터, SOAP         | 설정파일(k8s, CI/CD 등) |
| 경량성      | **가볍다**            | 무겁다                    | 가볍다                   |
| 주석 지원   | 없음                  | 지원 (`<!-- -->`)        | 지원 (`#`)              |
| 파싱 속도   | 빠름                  | 느림                      | 중간                     |

---

## 2. HTTPS와 SSL/TLS 인증서 기초

# HTTP & HTTPS

## 📌 HTTP란?
- 인터넷 상에서 정보를 주고 받기 위한 **프로토콜**(양식과 규칙의 체계)
- **클라이언트와 서버** 사이에서 이루어지는 **요청(Request)/응답(Response)** 기반의 통신
- **암호화되지 않은 방식**으로 데이터를 전송함  
  → 악의적인 감청, 데이터 변조의 위험 존재

## 📌 HTTPS란?
- **보안이 강화된 HTTP**
- `HTTPS` = Hypertext Transfer Protocol Over Secure Socket Layer
- 모든 HTTP 요청/응답 데이터가 **네트워크 전송 전에 암호화**됨
- **HTTP의 하부에 SSL/TLS와 같은 보안 계층**을 제공하여 동작함
- 즉, **HTTPS는 TCP 위에 놓인 보안 계층(SSL) 위의 HTTP**

## 📈 추가 설명 (views 기준)
- HTTPS는 HTTP를 **안전하게 만든 방식**
- HTTP가 **기본 통신 규약**이라면,  
  HTTPS는 **그 위에 보안을 얹은 구조**


### HTTPS (HyperText Transfer Protocol Secure)

HTTPS는 HTTP 위에 **SSL/TLS 프로토콜**을 덧붙여 암호화된 안전한 통신을 제공합니다. 주소창에 🔒 자물쇠가 보이면 HTTPS가 적용된 것입니다.

* **보안 기능**:
    1. **암호화 (Encryption)**: 데이터가 노출되지 않음.
    2. **무결성 (Integrity)**: 중간에 변조되지 않았음을 보장.
    3. **인증 (Authentication)**: 접속 서버가 신뢰할 수 있는지 확인.

### SSL/TLS 인증서 개요

* SSL은 과거의 명칭이고, 현재는 TLS가 정식 명칭입니다.
* **SSL 인증서**는 클라이언트에게 공개키를 제공하고 서버의 신원을 증명합니다.

### SSL 통신 흐름 이미지

![SSL 통신 과정](https://i.imgur.com/YIfy1wK.png)

### SSL/TLS 통신 단계 요약

1. **Client Hello**: 브라우저가 서버에 접속 요청. 암호화 방식, 무작위 값 포함.
2. **Server Hello**: 서버가 인증서와 암호화 방식, 무작위 값을 보냄.
3. **인증서 검증 및 Pre-Master Secret 생성**: 
    * 클라이언트는 서버의 공개키로 `pre master secret`을 암호화하여 전송.
4. **세션 키 생성**: 클라이언트와 서버는 동일한 `session key` 생성.
5. **세션 시작**: 이후 대칭키 방식으로 통신 → 빠르고 효율적.
6. **세션 종료**: 세션이 끝나면 세션 키 폐기.

---

## 3. 대칭키 vs 공개키 방식

| 구분       | 대칭키 방식          | 공개키 방식               |
|------------|-----------------------|----------------------------|
| 키 종류    | 1개 (같은 키 사용)     | 2개 (공개키 + 개인키)       |
| 속도       | 빠름                  | 느림                       |
| 보안성     | 키 노출 위험           | 안전                        |
| 사용 예시  | 세션 암호화           | 인증서 검증, 초기 키 교환   |

> ✅ **실제 통신**에서는 공개키로 대칭키를 교환한 뒤, 대칭키로 본격적인 데이터 암호화 수행 (성능 때문)

---

## 4. 디지털 서명 개요

디지털 서명은 전자 문서가 위변조되지 않았고, **정상적인 발신자**로부터 왔음을 증명하기 위해 사용됩니다.

![디지털 서명 구조](https://i.imgur.com/NWmUEzb.png)

### 디지털 서명 흐름 요약

1. **서명자**가 원본 데이터에 대해 해시 함수 적용.
2. 해시값을 개인키로 암호화 → 이것이 **디지털 서명**.
3. **수신자**는 서명자의 공개키로 서명을 복호화한 후,
4. 원본 데이터를 다시 해시 처리한 값과 비교 → 같으면 진위 확인.

* 해시함수: SHA-256, SHA-1 등 사용
* 용도: 공공기관 문서, 전자계약, 금융거래 등

---

## 참고

- SSL은 클라이언트와 서버 사이의 통신 암호화를 위한 프로토콜이며, HTTPS는 이를 웹에 적용한 표준입니다.
- 디지털 서명은 송신자의 **신원 확인과 데이터 위변조 방지**를 위한 기술입니다.

